#### 进程的关联启动与服务连接
- 主进程启动后会spawn子进程并指定命令行参数 `标识`
- 主进程侦听子进程控制台输出，如果输出中出现该 `标识`，则说明后台服务启动成功
- 当后台服务启动成功时读取后台服务信息文件 `backend_info`，其中包含命名管道名称等信息，主进程连接管道后即可与后台服务通信。

#### 协议格式说明
- 主进程与后台进程使用命名管道进行二进制数据传输，传输内容为 `头+体`。
- 头固定为四个字节，保存 `uint32be` 值，表示体的字节数。
- 体为 `JSON.stringify(json)` 的 `utf-8` 字节形式。
- 另有一种ping/pong格式，两种内容相同，发送即为ping，收到即为pong。这种只有四个字节的 `uint32be` 值，其实际值为 `0`，没有 `体` 部分

#### 协议处理
- 每种指定时间从客户端向服务端发送 ping 帧，服务端回应 pong 帧，以保持连接
- 服务端为go-winio实现，需要手动 `Read`，因此可以先读四个字节以确定体的长度，再读体的内容，不需要考虑半包粘包等情况。
- 客户端为nodejs实现，需要处理 `data` 事件，因此无法控制读取的字节数，需要处理半包粘包等情况。

#### stream封装为 request-response 模式
- 发送时在json中加入 `REQ_ID___` 字段，值为uuid，data事件获得完整数据时把该字段值带回
- 请求后返回一个promise对象，把其中的res、rej与`REQ_ID___` 字段的值关联起来，当data事件获得完整数据时根据其中的 `REQ_ID___` 字段值找到对应的res、rej进程调用，客户端即可得到结果

#### 其它
- 老版 `file_runner` 使用csharp winform实现，采用websocket的通信方式，同样把stream封装为request-response模式来使用
- 后来增加了go的后端实现 `gmap-backend`，用来把file_runner功能迁移过去
  - 原本采用grpc方式，使用比较笨重，但功能比较少，只实现了少数接口
  - 现打算改为ipc命名管道方式，不用暴露端口，使用也比较轻量