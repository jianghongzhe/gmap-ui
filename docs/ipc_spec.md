## 通信协议说明

### 一、协议格式说明
#### 1、ping/pong消息
| 名称           | 字节数 | 数据类型| 说明   |
|--------------|-----|-------|------|
| 桢头           | 4   | uint32be| 0值   |


#### 2、请求/响应业务消息
| 名称           | 字节数 | 数据类型     | 说明                                    |
|--------------|-----|----------|---------------------------------------|
| 桢头           | 4   | uint32be | 表示消息体的长度                              |
| 唯一编号，请求id    | 16  | 字节       | uuid的字节内容，并非uuid字符串（字符串需要32个字符，即32字节） |
| 消息体          | n   | 字节       | 消息体的内容，与帧头中指定的长度对应                    |
| 二进制内容计数器     | 4   | uint32be | 表示后面二进制数据的个数，如果为0则无后面的内容              |
| 第n个二进制内容桢头   | 4   | uint32be | 表示本二进制内容长度                            |
| 第n个二进制内容体    | n   | 字节       | 二进制内容                                 |
| 第n+1个二进制内容桢头 | 4   | uint32be |  表示本二进制内容长度                           |
| 第n+1个二进制内容体  | n   | 字节       | 二进制内容                             |

- 请求与响应消息格式相同
  - ping与pong的内容一致，发送即为ping，收到即为pong
  - 业务请求与响应的格式一致，请求中的`唯一编号`在响应时会带回，这样客户端可以把流式传输封装为请求响应方式
- 消息体为 `JSON.stringify(json)` 的 `utf-8` 字节形式，可通过配置指定是否gzip压缩及压缩级别。前后端的压缩配置要一致，否则无法解码。
- 二进制内容体也支持gzip压缩及压缩级别
- 关于唯一编号
  - 前一版本实现未设计专门的`唯一编号`部分，而是在`消息体`的json中插入一个`REQ_ID___` 字段，这样后端处理时需要在业务代码中手动处理，比如从请求中取出`REQ_ID___`，响应返回时再手动加入`REQ_ID___`。
  - 这样实现不优雅，也增加了传输压力。
    - `唯一编号`的对应关系应该在框架层面实现，而不是在业务代码中。
    - 按uuid字符串传输需要32个字符，即32字节，而uuid字节内容只有16字节，还需要`REQ_ID___`属性本身。


### 二、通信方式
- 通信方式为`命令管道`，消息格式为byte，不是message，需要手动处理半包粘包等情况。
- 每过指定时间从客户端向服务端发送 ping 帧，服务端回应 pong 帧，以保持连接。
- 服务端为go-winio实现，客户端为nodejs实现。
